<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.31.1">
    <meta name="project" content="jinterface v1.14.1">


    <title>The Jinterface Package — jinterface v1.14.1</title>
    <link rel="stylesheet" href="dist/html-erlang-YUARVD4J.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-43PMFBC7.js"></script>
    <script src="dist/sidebar_items-8C3C9319.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/html-L4O5OK2K.js"></script>

<style>.dark img { background-color: white; }</style>
  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<div class="background-layer"></div>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="../../index.html" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="jinterface" />
        </a>

      <div>
        <a href="../../index.html" class="sidebar-projectName" translate="no">
jinterface
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v1.14.1
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">
      <div class="top-search">
        <div class="search-settings">
          <form class="search-bar" action="search.html">
            <label class="search-label">
              <span class="sr-only">Search documentation of jinterface</span>
              <input name="q" type="text" class="search-input" placeholder="Search Documentation (press /)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
            </label>
            <button type="submit" class="search-button" aria-label="Submit Search">
              <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
            </button>
            <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
              <i class="ri-close-line ri-lg" title="Cancel search"></i>
            </button>
          </form>
          <div class="autocomplete">
          </div>
          <button class="icon-settings display-settings">
            <i class="ri-settings-3-line"></i>
            <span class="sr-only">Settings</span>
          </button>
        </div>

      </div>

<h1>

    <a href="https://github.com/erlang/otp/blob/master/lib/jinterface/doc/guides/jinterface_users_guide.md#L1" title="View Source" class="icon-action" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>


  <span>The Jinterface Package</span>
</h1>

<p>The <a href="assets/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a>
package provides a set of tools for communication with Erlang processes. It can
also be used for communication with other Java processes using the same package,
as well as C processes using the Erl_Interface library.</p><p>The set of classes in the package can be divided into two categories: those that
provide the actual communication, and those that provide a Java representation
of the Erlang data types. The latter are all subclasses of OtpErlangObject, and
they are identified by the OtpErlang prefix.</p><p>Since this package provides a mechanism for communicating with Erlang, message
recipients can be Erlang processes or instances of
com.ericsson.otp.erlang.OtpMbox, both of which are identified with pids and
possibly registered names. When pids or mailboxes are mentioned as message
senders or recipients in this section, it should assumed that even Erlang
processes are included, unless specified otherwise. The classes in
<a href="assets/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a> support
the following:</p><ul><li>manipulation of data represented as Erlang data types</li><li>conversion of data between Java and Erlang formats</li><li>encoding and decoding of Erlang data types for transmission or storage</li><li>communication between Java nodes and Erlang processes</li></ul><p>In the following sections, these topics are described:</p><ul><li>mapping of Erlang types to Java</li><li>encoding, decoding, and sending Erlang terms</li><li>connecting to a distributed Erlang node</li><li>using nodes, mailboxes and EPMD</li><li>sending and receiving Erlang messages and data</li><li>remote procedure calls</li><li>linking to remote processes</li><li>compiling your code for use with Jinterface</li><li>tracing message flow</li></ul><h2 id="mapping-of-basic-erlang-types-to-java" class="section-heading">
  <a href="#mapping-of-basic-erlang-types-to-java" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Mapping of Basic Erlang Types to Java</span>
</h2>
<p>This section describes the mapping of Erlang basic types to Java.</p><table><thead><tr><th style="text-align: left;">Erlang type</th><th style="text-align: left;">Java type</th></tr></thead><tbody><tr><td style="text-align: left;">atom</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangAtom.html">OtpErlangAtom</a></td></tr><tr><td style="text-align: left;">binary</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangBinary.html">OtpErlangBinary</a></td></tr><tr><td style="text-align: left;">floating point types</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangFloat.html">OtpErlangFloat</a> or <a href="assets/java/com/ericsson/otp/erlang/OtpErlangDouble.html">OtpErlangDouble</a>, depending on the floating point value size</td></tr><tr><td style="text-align: left;">integral types</td><td style="text-align: left;">One of <a href="assets/java/com/ericsson/otp/erlang/OtpErlangByte.html">OtpErlangByte</a>, <a href="assets/java/com/ericsson/otp/erlang/OtpErlangChar.html">OtpErlangChar</a>, <a href="assets/java/com/ericsson/otp/erlang/OtpErlangShort.html">OtpErlangShort</a>, <a href="assets/java/com/ericsson/otp/erlang/OtpErlangUShort.html">OtpErlangUShort</a>, <a href="assets/java/com/ericsson/otp/erlang/OtpErlangInt.html">OtpErlangInt</a>, <a href="assets/java/com/ericsson/otp/erlang/OtpErlangUInt.html">OtpErlangUInt</a> or <a href="assets/java/com/ericsson/otp/erlang/OtpErlangLong.html">OtpErlangLong</a>, depending on the integral value size and sign</td></tr><tr><td style="text-align: left;">list</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangList.html">OtpErlangList</a></td></tr><tr><td style="text-align: left;">pid</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangPid.html">OtpErlangPid</a></td></tr><tr><td style="text-align: left;">port</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangPort.html">OtpErlangPort</a></td></tr><tr><td style="text-align: left;">ref</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangRef.html">OtpErlangRef</a></td></tr><tr><td style="text-align: left;">tuple</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangTuple.html">OtpErlangTuple</a></td></tr><tr><td style="text-align: left;">map</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangMap.html">OtpErlangMap</a></td></tr><tr><td style="text-align: left;">term</td><td style="text-align: left;"><a href="assets/java/com/ericsson/otp/erlang/OtpErlangObject.html">OtpErlangObject</a></td></tr></tbody></table><p><em>Table: Mapping of Erlang basic types to Java</em></p><h2 id="special-mapping-issues" class="section-heading">
  <a href="#special-mapping-issues" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Special Mapping Issues</span>
</h2>
<p>The atoms <code class="inline">true</code> and <code class="inline">false</code> are special atoms, used as boolean values. The
class
<a href="assets/java/com/ericsson/otp/erlang/OtpErlangBoolean.html">OtpErlangBoolean</a>
can be used to represent these.</p><p>Lists in Erlang are also used to describe sequences of printable characters
(strings). A convenience class
<a href="assets/java/com/ericsson/otp/erlang/OtpErlangString.html">OtpErlangString</a> is
provided to represent Erlang strings.</p><h2 id="nodes" class="section-heading">
  <a href="#nodes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Nodes</span>
</h2>
<p>A node as defined by Erlang/OTP is an instance of the Erlang Runtime System, a
virtual machine roughly equivalent to a JVM. Each node has a unique name in the
form of an identifier composed partly of the hostname on which the node is
running, e.g &quot;gurka@sallad.com&quot;. Several such nodes can run on the same host as
long as their names are unique. The class
<a href="assets/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a> represents an Erlang
node.</p><p>It is created with a name and optionally a TCP/IP socket port number on which it
listens for incoming connections. By default before creating an instance of
<a href="assets/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a>, ensure that Epmd is
running on the host machine. See the Erlang documentation for more information
about Epmd.</p><p>In this example, the host name is appended automatically to the identifier, and
the port number is chosen by the underlying system:</p><pre><code class="makeup erlang" translate="no"><span class="n">OtpNode</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpNode</span><span class="p" data-group-id="8167209489-1">(</span><span class="s">&quot;gurka&quot;</span><span class="p" data-group-id="8167209489-1">)</span><span class="p">;</span></code></pre><p>It is also possible to use alternative communication (or distribution) protocols
without Epmd by switching to a custom transport factory extending the
OtpGenericTransportFactory abstract class, for example based on Unix Domain
Sockets instead of the default TCP/IP sockets.</p><p>In this example, the host name is appended automatically to the identifier and a
custom transport factory is used:</p><pre><code class="makeup erlang" translate="no"><span class="n">OtpGenericTransportFactory</span><span class="w"> </span><span class="ss">customFactory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">MyCustomFactory</span><span class="p" data-group-id="1658409176-1">(</span><span class="p" data-group-id="1658409176-1">)</span><span class="p">;</span><span class="w">
</span><span class="n">OtpNode</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpNode</span><span class="p" data-group-id="1658409176-2">(</span><span class="s">&quot;gurka&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">customFactory</span><span class="p" data-group-id="1658409176-2">)</span><span class="p">;</span></code></pre><h2 id="mailboxes" class="section-heading">
  <a href="#mailboxes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Mailboxes</span>
</h2>
<p>Erlang processes running on an Erlang node are identified by process identifiers
(pids) and, optionally, by registered names unique within the node. Each Erlang
process has an implicit mailbox that is used to receive messages; the mailbox is
identified with the pid of the process.</p><p>Jinterface provides a similar mechanism with the class
<a href="assets/java/com/ericsson/otp/erlang/OtpMbox.html">OtpMbox</a>, a mailbox that can
be used to send and receive messages asynchronously. Each OtpMbox is identified
with a unique pid and , optionally, a registered name unique within the
<a href="assets/java/com/ericsson/otp/erlang/OtpNode.html">OtpNode</a>.</p><p>Applications are free to create mailboxes as necessary. This is done as follows:</p><pre><code class="text">        OtpMbox mbox = node.createMbox();</code></pre><p>The mailbox created in the above example has no registered name, although it
does have a pid. The pid can be obtained from the mailbox and included in
messages sent from the mailbox, so that remote processes are able to respond.</p><p>An application can register a name for a mailbox, either when the mailbox is
initially created:</p><pre><code class="text">        OtpMbox mbox = node.createMbox(&quot;server&quot;);</code></pre><p>or later on, as necessary:</p><pre><code class="makeup erlang" translate="no"><span class="w">        </span><span class="n">OtpMbox</span><span class="w"> </span><span class="ss">mbox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">node</span><span class="p">.</span><span class="nf">createMbox</span><span class="p" data-group-id="1815762170-1">(</span><span class="p" data-group-id="1815762170-1">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">mbox</span><span class="p">.</span><span class="nf">registerName</span><span class="p" data-group-id="1815762170-2">(</span><span class="s">&quot;server&quot;</span><span class="p" data-group-id="1815762170-2">)</span><span class="p">;</span></code></pre><p>Registered names are usually necessary in order to start communication, since it
is impossible to know in advance the pid of a remote process. If a well-known
name for one of the processes is chosen in advance and known by all
communicating parties within an application, each mailbox can send an initial
message to the named mailbox, which then can identify the sender pid.</p><h2 id="connections" class="section-heading">
  <a href="#connections" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Connections</span>
</h2>
<p>It is not necessary to explicitly set up communication with a remote node.
Simply sending a message to a mailbox on that node will cause the OtpNode to
create a connection if one does not already exist. Once the connection is
established, subsequent messages to the same node will reuse the same
connection.</p><p>It is possible to check for the existence of a remote node before attempting to
communicate with it. Here we send a ping message to the remote node to see if it
is alive and accepting connections:</p><pre><code class="text">        if (node.ping(&quot;remote&quot;,2000)) {
          System.out.println(&quot;remote is up&quot;);
        }
        else {
          System.out.println(&quot;remote is not up&quot;);
       }</code></pre><p>If the call to ping() succeeds, a connection to the remote node has been
established. Note that it is not necessary to ping remote nodes before
communicating with them, but by using ping you can determine if the remote
exists before attempting to communicate with it.</p><p>Connections are only permitted by nodes using the same security cookie. The
cookie is a short string provided either as an argument when creating OtpNode
objects, or found in the user's home directory in the file <code class="inline">.erlang.cookie</code>.
When a connection attempt is made, the string is used as part of the
authentication process. If you are having trouble getting communication to work,
use the trace facility (described later in this document) to show the connection
establishment. A likely problem is that the cookies are different.</p><p>Connections are never broken explicitly. If a node fails or is closed, a
connection may be broken however.</p><h2 id="transport-factory" class="section-heading">
  <a href="#transport-factory" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Transport Factory</span>
</h2>
<p>All necessary connections are made using methods of
<a href="assets/java/com/ericsson/otp/erlang/OtpTransportFactory.html">OtpTransportFactory</a>
interface. The default OtpTransportFactory implementation is based on standard
TCP/IP Socket class and relies on epmd. User may provide custom transport
factory as needed. See java doc for details.</p><p>For alternative distribution protocols working without epmd, using a transport
factory extending the
<a href="assets/java/com/ericsson/otp/erlang/OtpGenericTransportFactory.html">OtpGenericTransportFactory</a>
abstract class will disable the automatic epmd registration and lookup in
Jinterface.</p><h2 id="sending-and-receiving-messages" class="section-heading">
  <a href="#sending-and-receiving-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending and Receiving Messages</span>
</h2>
<p>Messages sent with this package must be instances of
<a href="assets/java/com/ericsson/otp/erlang/OtpErlangObject.html">OtpErlangObject</a> or
one of its subclasses. Message can be sent to processes or pids, either by
specifying the pid of the remote, or its registered name and node.</p><p>In this example, we create a message containing our own pid so the echo process
can reply:</p><pre><code class="makeup erlang" translate="no"><span class="w">        </span><span class="n">OtpErlangObject</span><span class="p" data-group-id="0050678816-1">[</span><span class="p" data-group-id="0050678816-1">]</span><span class="w"> </span><span class="ss">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpErlangObject</span><span class="p" data-group-id="0050678816-2">[</span><span class="mi">2</span><span class="p" data-group-id="0050678816-2">]</span><span class="p">;</span><span class="w">
        </span><span class="ss">msg</span><span class="p" data-group-id="0050678816-3">[</span><span class="mi">0</span><span class="p" data-group-id="0050678816-3">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">mbox</span><span class="p">.</span><span class="nf">self</span><span class="p" data-group-id="0050678816-4">(</span><span class="p" data-group-id="0050678816-4">)</span><span class="p">;</span><span class="w">
        </span><span class="ss">msg</span><span class="p" data-group-id="0050678816-5">[</span><span class="mi">1</span><span class="p" data-group-id="0050678816-5">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpErlangAtom</span><span class="p" data-group-id="0050678816-6">(</span><span class="s">&quot;hello, world&quot;</span><span class="p" data-group-id="0050678816-6">)</span><span class="p">;</span><span class="w">
        </span><span class="n">OtpErlangTuple</span><span class="w"> </span><span class="ss">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpErlangTuple</span><span class="p" data-group-id="0050678816-7">(</span><span class="ss">msg</span><span class="p" data-group-id="0050678816-7">)</span><span class="p">;</span></code></pre><p>When we send the message, a connection will be created:</p><pre><code class="text">        mbox.send(&quot;echo&quot;, &quot;gurka@sallad.com&quot;, tuple);</code></pre><p>And here we receive the reply:</p><pre><code class="text">        OtpErlangObject reply = mbox.receive();</code></pre><p>Messages are sent asynchronously, so the call to <code class="inline">send()</code> returns as soon as the
message has been dispatched to the underlying communication layer. This means
that you receive no indication whether the operation completed successfully or
the remote even existed. If you need this kind of confirmation, you should wait
for a response from the remote process.</p><p>The echo server itself might look like this:</p><pre><code class="makeup erlang" translate="no"><span class="w">    </span><span class="n">OtpNode</span><span class="w"> </span><span class="ss">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">new</span><span class="w"> </span><span class="n">OtpNode</span><span class="p" data-group-id="4843991389-1">(</span><span class="s">&quot;gurka&quot;</span><span class="p" data-group-id="4843991389-1">)</span><span class="p">;</span><span class="w">
    </span><span class="n">OtpMbox</span><span class="w"> </span><span class="ss">mbox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">self</span><span class="p">.</span><span class="nf">createMbox</span><span class="p" data-group-id="4843991389-2">(</span><span class="s">&quot;echo&quot;</span><span class="p" data-group-id="4843991389-2">)</span><span class="p">;</span><span class="w">
    </span><span class="n">OtpErlangObject</span><span class="w"> </span><span class="ss">o</span><span class="p">;</span><span class="w">
    </span><span class="n">OtpErlangTuple</span><span class="w"> </span><span class="ss">msg</span><span class="p">;</span><span class="w">
    </span><span class="n">OtpErlangPid</span><span class="w"> </span><span class="ss">from</span><span class="p">;</span><span class="w">

    </span><span class="nf">while</span><span class="w"> </span><span class="p" data-group-id="4843991389-3">(</span><span class="ss">true</span><span class="p" data-group-id="4843991389-3">)</span><span class="w"> </span><span class="p" data-group-id="4843991389-4">{</span><span class="w">
      </span><span class="k">try</span><span class="w"> </span><span class="p" data-group-id="4843991389-5">{</span><span class="w">
        </span><span class="ss">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">mbox</span><span class="p">.</span><span class="nf">receive</span><span class="p" data-group-id="4843991389-6">(</span><span class="p" data-group-id="4843991389-6">)</span><span class="p">;</span><span class="w">
        </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="4843991389-7">(</span><span class="ss">o</span><span class="w"> </span><span class="ss">instanceof</span><span class="w"> </span><span class="n">OtpErlangTuple</span><span class="p" data-group-id="4843991389-7">)</span><span class="w"> </span><span class="p" data-group-id="4843991389-8">{</span><span class="w">
          </span><span class="ss">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4843991389-9">(</span><span class="n">OtpErlangTuple</span><span class="p" data-group-id="4843991389-9">)</span><span class="ss">o</span><span class="p">;</span><span class="w">
          </span><span class="ss">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4843991389-10">(</span><span class="n">OtpErlangPid</span><span class="p" data-group-id="4843991389-10">)</span><span class="p" data-group-id="4843991389-11">(</span><span class="ss">msg</span><span class="p">.</span><span class="nf">elementAt</span><span class="p" data-group-id="4843991389-12">(</span><span class="mi">0</span><span class="p" data-group-id="4843991389-12">)</span><span class="p" data-group-id="4843991389-11">)</span><span class="p">;</span><span class="w">
          </span><span class="ss">mbox</span><span class="p">.</span><span class="nf">send</span><span class="p" data-group-id="4843991389-13">(</span><span class="ss">from</span><span class="p">,</span><span class="ss">msg</span><span class="p">.</span><span class="nf">elementAt</span><span class="p" data-group-id="4843991389-14">(</span><span class="mi">1</span><span class="p" data-group-id="4843991389-14">)</span><span class="p" data-group-id="4843991389-13">)</span><span class="p">;</span><span class="w">
      </span><span class="p" data-group-id="4843991389-8">}</span><span class="w">
      </span><span class="nf">catch</span><span class="w"> </span><span class="p" data-group-id="4843991389-15">(</span><span class="n">Exception</span><span class="w"> </span><span class="ss">e</span><span class="p" data-group-id="4843991389-15">)</span><span class="w"> </span><span class="p" data-group-id="4843991389-16">{</span><span class="w">
        </span><span class="n">System</span><span class="p">.</span><span class="ss">out</span><span class="p">.</span><span class="nf">println</span><span class="p" data-group-id="4843991389-17">(</span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="ss">e</span><span class="p" data-group-id="4843991389-17">)</span><span class="p">;</span><span class="w">
      </span><span class="p" data-group-id="4843991389-16">}</span><span class="w">
    </span><span class="p" data-group-id="4843991389-5">}</span></code></pre><p>In the examples above, only one mailbox was created on each node. however you
are free to create as many mailboxes on each node as you like. You are also free
to create as many nodes as you like on each JVM, however because each node uses
some limited system resources such as file descriptors, it is recommended that
you create only a small number of nodes (such as one) on each JVM.</p><h2 id="sending-arbitrary-data" class="section-heading">
  <a href="#sending-arbitrary-data" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending Arbitrary Data</span>
</h2>
<p>This package was originally intended to be used for communicating between Java
and Erlang, and for that reason the send and receive methods all use Java
representations of Erlang data types.</p><p>However it is possible to use the package to communicate with remote processes
written in Java as well, and in these cases it may be desirable to send other
data types.</p><p>The simplest way to do this is to encapsulate arbitrary data in messages of type
<a href="assets/java/com/ericsson/otp/erlang/OtpErlangBinary.html">OtpErlangBinary</a>. The
OtpErlangBinary class can be created from arbitrary Java objects that implement
the Serializable or Externalizable interface:</p><pre><code class="text">        o = new MyClass(foo);
        mbox.send(remote,new OtpErlangBinary(o));</code></pre><p>The example above will cause the object to be serialized and encapsulated in an
OtpErlangBinary before being sent. The recipient will receive an OtpErlangBinary
but can extract the original object from it:</p><pre><code class="makeup erlang" translate="no"><span class="w">        </span><span class="ss">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">mbox</span><span class="p">.</span><span class="nf">receive</span><span class="p" data-group-id="1001731596-1">(</span><span class="p" data-group-id="1001731596-1">)</span><span class="p">;</span><span class="w">
        </span><span class="nf">if</span><span class="w"> </span><span class="p" data-group-id="1001731596-2">(</span><span class="ss">msg</span><span class="w"> </span><span class="ss">instanceof</span><span class="w"> </span><span class="n">OtpErlangBinary</span><span class="p" data-group-id="1001731596-2">)</span><span class="w"> </span><span class="p" data-group-id="1001731596-3">{</span><span class="w">
           </span><span class="n">OtpErlangBinary</span><span class="w"> </span><span class="ss">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1001731596-4">(</span><span class="n">OtpErlangBinary</span><span class="p" data-group-id="1001731596-4">)</span><span class="ss">msg</span><span class="p">;</span><span class="w">
           </span><span class="n">MyClass</span><span class="w"> </span><span class="ss">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1001731596-5">(</span><span class="n">MyClass</span><span class="p" data-group-id="1001731596-5">)</span><span class="p" data-group-id="1001731596-6">(</span><span class="ss">b</span><span class="p">.</span><span class="nf">getObject</span><span class="p" data-group-id="1001731596-7">(</span><span class="p" data-group-id="1001731596-7">)</span><span class="p" data-group-id="1001731596-6">)</span><span class="p">;</span><span class="w">
        </span><span class="p" data-group-id="1001731596-3">}</span></code></pre><h2 id="linking-to-remote-processes" class="section-heading">
  <a href="#linking-to-remote-processes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Linking to Remote Processes</span>
</h2>
<p>Erlang defines a concept known as linked processes. A link is an implicit
connection between two processes that causes an exception to be raised in one of
the processes if the other process terminates for any reason. Links are
bidirectional: it does not matter which of the two processes created the link or
which of the linked processes eventually terminates; an exception will be raised
in the remaining process. Links are also idempotent: at most one link can exist
between two given processes, only one operation is necessary to remove the link.</p><p>Jinterface provides a similar mechanism. Also here, no distinction is made
between mailboxes and Erlang processes. A link can be created to a remote
mailbox or process when its pid is known:</p><pre><code class="text">        mbox.link(remote);</code></pre><p>The link can be removed by either of the processes in a similar manner:</p><pre><code class="text">        mbox.unlink(remote);</code></pre><p>If the remote process terminates while the link is still in place, an exception
will be raised on a subsequent call to receive():</p><pre><code class="text">        try {
          msg = mbox.receive();
        }
        catch (OtpErlangExit e) {
          System.out.println(&quot;Remote pid &quot; + e.pid() + &quot; has terminated&quot;);
        }
        catch (OtpErlangDecodeException f) {
          System.out.println(&quot;Received message could not be decoded: &quot; + f);
        }</code></pre><p>When a mailbox is explicitly closed, exit messages will be sent in order to
break any outstanding links. If a mailbox is never closed but instead goes out
of scope, the objects <code class="inline">finalize()</code> method will call <code class="inline">close()</code>. However since
Java provides no guarantees about when or even if finalize() will be called, it
is important that your application explicitly closes mailboxes when they are no
longer needed if you want links to work in a timely manner.</p><h2 id="using-epmd" class="section-heading">
  <a href="#using-epmd" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using EPMD</span>
</h2>
<p>Epmd is the Erlang Port Mapper Daemon. By default distributed Erlang nodes
register with epmd on the localhost to indicate to other nodes that they exist
and can accept connections. Epmd maintains a register of node and socket port
number information, and when a node wishes to connect to another node, it first
contacts epmd in order to find out the correct socket port number to connect to.
It is also possible to use alternative distribution protocols which don't need
epmd at all.</p><p>The basic interaction with EPMD is done through instances of
<a href="assets/java/com/ericsson/otp/erlang/OtpEpmd.html">OtpEpmd</a> class. Nodes wishing
to contact other nodes must first request information from Epmd before a
connection can be set up, however this is done automatically by
<a href="assets/java/com/ericsson/otp/erlang/OtpSelf.html#connect%28com.ericsson.otp.erlang.OtpPeer%29">OtpSelf.connect()</a>
when necessary.</p><p>When you use
<a href="assets/java/com/ericsson/otp/erlang/OtpSelf.html#connect%28com.ericsson.otp.erlang.OtpPeer%29">OtpSelf.connect()</a>
to connect to an Erlang node, a connection is first made to epmd and, if the
node is known, a connection is then made to the Erlang node.</p><p>Java nodes can also register themselves with epmd if they want other nodes in
the system to be able to find and connect to them. This is done by call to
method
<a href="assets/java/com/ericsson/otp/erlang/OtpEpmd.html#publishPort%28com.ericsson.otp.erlang.OtpLocalNode%29">OtpEpmd.publishPort()</a>.</p><p>Be aware that on some systems a failed node will not be detected by this
mechanism since the operating system does not automatically close descriptors
that were left open when the node failed. If a node has failed in this way, epmd
will prevent you from registering a new node with the old name, since it thinks
that the old name is still in use. In this case, you must unregister the name
explicitly, by using
<a href="assets/java/com/ericsson/otp/erlang/OtpEpmd.html#unPublishPort%28com.ericsson.otp.erlang.OtpLocalNode%29">OtpEpmd.unPublishPort()</a></p><p>This will cause epmd to close the connection from the far end. Note that if the
name was in fact still in use by a node, the results of this operation are
unpredictable. Also, doing this does not cause the local end of the connection
to close, so resources may be consumed.</p><h2 id="remote-procedure-calls" class="section-heading">
  <a href="#remote-procedure-calls" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Remote Procedure Calls</span>
</h2>
<p>An Erlang node acting as a client to another Erlang node typically sends a
request and waits for a reply. Such a request is included in a function call at
a remote node and is called a remote procedure call. Remote procedure calls are
supported through the class
<a href="assets/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection</a>. The
following example shows how the
<a href="assets/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection</a> class is
used for remote procedure calls:</p><pre><code class="makeup c" translate="no"><span class="w">
</span><span class="no">OtpSelf</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="no">OtpSelf</span><span class="p" data-group-id="1465307051-1">(</span><span class="s">&quot;client&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hejsan&quot;</span><span class="w"> </span><span class="p" data-group-id="1465307051-1">)</span><span class="p">;</span><span class="w">
</span><span class="no">OtpPeer</span><span class="w"> </span><span class="n">other</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="no">OtpPeer</span><span class="p" data-group-id="1465307051-2">(</span><span class="s">&quot;server@balin&quot;</span><span class="p" data-group-id="1465307051-2">)</span><span class="p">;</span><span class="w">
</span><span class="no">OtpConnection</span><span class="w"> </span><span class="n">connection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">connect</span><span class="p" data-group-id="1465307051-3">(</span><span class="n">other</span><span class="p" data-group-id="1465307051-3">)</span><span class="p">;</span><span class="w">

</span><span class="n">connection</span><span class="p">.</span><span class="nf">sendRPC</span><span class="p" data-group-id="1465307051-4">(</span><span class="s">&quot;erlang&quot;</span><span class="p">,</span><span class="s">&quot;date&quot;</span><span class="p">,</span><span class="k">new</span><span class="w"> </span><span class="no">OtpErlangList</span><span class="p" data-group-id="1465307051-5">(</span><span class="p" data-group-id="1465307051-5">)</span><span class="p" data-group-id="1465307051-4">)</span><span class="p">;</span><span class="w">
</span><span class="no">OtpErlangObject</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">connection</span><span class="p">.</span><span class="nf">receiveRPC</span><span class="p" data-group-id="1465307051-6">(</span><span class="p" data-group-id="1465307051-6">)</span><span class="p">;</span></code></pre><p><a href="../../apps/erts/erlang.html#date/0"><code class="inline">erlang:date/0</code></a> is just called to get the date tuple from a remote host.</p><h2 id="compiling-and-loading-your-code" class="section-heading">
  <a href="#compiling-and-loading-your-code" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Compiling and Loading Your Code</span>
</h2>
<p>In order to use any of the
<a href="assets/java/com/ericsson/otp/erlang/package-summary.html">Jinterface</a> classes,
include the following line in your code:</p><pre><code class="text">import com.ericsson.otp.erlang.*;</code></pre><p>Determine where the top directory of your OTP installation is. You can find this
out by starting Erlang and entering the following command at the Eshell prompt:</p><pre><code class="text">Eshell V4.9.1.2  (abort with ^G)
1&gt; code:root_dir().
/usr/local/otp</code></pre><p>To compile your code, make sure that your Java compiler knows where to find the
file <code class="inline">OtpErlang.jar</code> which contains the package. This is done by specifying an
appropriate <code class="inline">-classpath</code> argument on the command line, or by adding it to the
<code class="inline">CLASSPATH</code> definition in your <code class="inline">Makefile</code>. The correct value for this path is
<code class="inline">$OTPROOT/lib/jinterface</code><em>Vsn</em><code class="inline">/priv/OtpErlang.jar</code>, where <code class="inline">$OTPROOT</code> is the
path reported by <a href="../../apps/kernel/code.html#root_dir/0"><code class="inline">code:root_dir/0</code></a> in the above example and <em>Vsn</em> is the version
of Jinterface, for example <code class="inline">jinterface-1.2</code></p><pre><code class="text">$ javac -classpath &quot;.:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar&quot;
                    myclass.java</code></pre><p>When running your program, you will also need to specify the path to
<code class="inline">OtpErlang.jar</code> in a similar way.</p><pre><code class="text">$ java &quot;.:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar&quot; myclass</code></pre><h2 id="tracing" class="section-heading">
  <a href="#tracing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Tracing</span>
</h2>
<p>Communication between nodes can be traced by setting a system property before
the communication classes in this package are initialized. The value system
property &quot;OtpConnection.trace&quot; is the default trace level for all connections.
Normally the default trace level is zero, i.e. no tracing is performed. By
setting
<a href="assets/java/com/ericsson/otp/erlang/OtpConnection.html">OtpConnection.trace</a> to
some non-zero value, the communication protocol can be shown in more or less
detail. The valid values are:</p><ul><li>0: no tracing is performed</li><li>1: only ordinary send and reg-send messages are shown</li><li>2: control messages such as link, unlink and exit are shown</li><li>3: connection setup (handshake) is shown</li><li>4: epmd requests are shown</li></ul><p>Each level also includes the information shown by all lower levels.</p>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="notes.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Jinterface Release Notes
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

  </div>
</div>
      <footer class="footer">
        <p>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
              Search HexDocs
            </button>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.31.1) for the

            <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

        </p>
      </footer>
    </div>
  </div>
</main>
</div>


  </body>
</html>
